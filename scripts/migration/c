import sql from 'mssql';
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

// Configuraci√≥n SQL Server
const sqlConfig = {
    server: process.env.SQLSERVER_SERVER,
    port: parseInt(process.env.SQLSERVER_PORT),
    user: process.env.SQLSERVER_USER,
    password: process.env.SQLSERVER_PASSWORD,
    database: process.env.SQLSERVER_DATABASE,
    options: {
        encrypt: false,
        trustServerCertificate: true
    }
};

// Configuraci√≥n Supabase
const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY
);

// Mapeo de Entidades: SQL Server usa campo "Entidad" con valores 0=Socios, 1=Profesionales
const entidadMap = {
    0: 0, // Socios
    1: 1  // Profesionales
};

/**
 * Funci√≥n principal de migraci√≥n de Cuentas Corrientes
 */
async function migrateCuentasCorrientes() {
    console.log('üîÑ Iniciando migraci√≥n de Cuentas Corrientes...');

    try {
        // PASO 1: Limpiar tablas de destino
        console.log('\nüìã PASO 1: Limpiando tablas en Supabase...');

        // Eliminar detalles primero (por FK)
        const { error: deleteDetalleError } = await supabase
            .from('detalle_cuentas_corrientes')
            .delete()
            .neq('idtransaccion', -1); // Delete all

        if (deleteDetalleError) {
            console.error('‚ùå Error limpiando detalle_cuentas_corrientes:', deleteDetalleError.message);
        } else {
            console.log('‚úÖ Tabla detalle_cuentas_corrientes limpiada');
        }

        // Eliminar headers
        const { error: deleteCCError } = await supabase
            .from('cuentas_corrientes')
            .delete()
            .neq('idtransaccion', -1); // Delete all

        if (deleteCCError) {
            console.error('‚ùå Error limpiando cuentas_corrientes:', deleteCCError.message);
        } else {
            console.log('‚úÖ Tabla cuentas_corrientes limpiada');
        }

        // PASO 2: Cargar mapeos necesarios
        console.log('\nüìã PASO 2: Cargando mapeos de referencia...');

        // Mapeo de socios (SQL Server ID -> Supabase ID)
        // Cargar TODOS los socios (sin l√≠mite de 1000)
        let allSocios = [];
        let from = 0;
        const pageSize = 1000;

        while (true) {
            const { data: sociosData, error: sociosError } = await supabase
                .from('socios')
                .select('id')
                .range(from, from + pageSize - 1);

            if (sociosError) {
                console.error('‚ùå Error cargando socios:', sociosError);
                throw sociosError;
            }

            if (!sociosData || sociosData.length === 0) break;

            allSocios = allSocios.concat(sociosData);

            if (sociosData.length < pageSize) break;
            from += pageSize;
        }

        const sociosIds = new Set(allSocios.map(s => s.id));
        console.log(`‚úÖ Cargados ${sociosIds.size} socios`);

        // Mapeo de profesionales (si existen)
        const { data: profesionalesData } = await supabase
            .from('profesionales')
            .select('id');
        const profesionalesIds = new Set((profesionalesData || []).map(p => p.id));
        console.log(`‚úÖ Cargados ${profesionalesIds.size} profesionales`);

        // Mapeo de conceptos
        const { data: conceptosData, error: conceptosError } = await supabase
            .from('conceptos')
            .select('concepto');

        if (conceptosError) {
            console.error('‚ùå Error cargando conceptos:', conceptosError);
            throw conceptosError;
        }
        const conceptosCodigos = new Set(conceptosData.map(c => c.concepto));
        console.log(`‚úÖ Cargados ${conceptosCodigos.size} conceptos`);

        // PASO 3: Conectar a SQL Server y migrar headers
        console.log('\nüìã PASO 3: Migrando cuentas_corrientes (headers)...');
        const pool = await sql.connect(sqlConfig);

        const headersQuery = `
            SELECT
                IdTransaccion as idtransaccion,
                socio as socio_id,
                Entidad as entidad_id,
                Fecha as fecha,
                Concepto as tipo_comprobante,  -- IMPORTANTE: renombrado
                PuntodeVenta as punto_venta,
                DocumentoNumero as documento_numero,
                FechaRendicion as fecha_rendicion,
                Rendicion as rendicion,
                importe,
                Cancelado as cancelado,
                vencimiento
            FROM cuentascorrientes
            WHERE socio < 10000  -- Solo socios menores a 10000
            ORDER BY IdTransaccion
        `;

        const headersResult = await pool.request().query(headersQuery);
        console.log(`üìñ Encontrados ${headersResult.recordset.length} registros en SQL Server`);

        // Procesar en lotes de 500
        const BATCH_SIZE = 500;
        let successCount = 0;
        let skippedCount = 0;
        const errors = [];

        for (let i = 0; i < headersResult.recordset.length; i += BATCH_SIZE) {
            const batch = headersResult.recordset.slice(i, i + BATCH_SIZE);

            const headersToInsert = batch.map(row => {
                const entidadId = entidadMap[row.entidad_id] ?? 0; // Default a Socios si es null

                // Validar que el socio o profesional existe
                const referenciaId = row.socio_id;
                if (entidadId === 0 && !sociosIds.has(referenciaId)) {
                    errors.push(`Socio ${referenciaId} no existe (idtransaccion: ${row.idtransaccion})`);
                    return null;
                }
                if (entidadId === 1 && !profesionalesIds.has(referenciaId)) {
                    errors.push(`Profesional ${referenciaId} no existe (idtransaccion: ${row.idtransaccion})`);
                    return null;
                }

                // Asegurar que tipo_comprobante tenga exactamente 3 caracteres (SQL Server lo trim pero necesitamos el espacio)
                const tipoComprobante = row.tipo_comprobante?.trim() || '';
                const tipoComprobantePadded = tipoComprobante.padEnd(3, ' ');

                return {
                    idtransaccion: row.idtransaccion,
                    socio_id: entidadId === 0 ? referenciaId : null,
                    profesional_id: entidadId === 1 ? referenciaId : null,
                    entidad_id: entidadId,
                    fecha: row.fecha ? new Date(row.fecha).toISOString().split('T')[0] : null,
                    tipo_comprobante: tipoComprobantePadded,
                    punto_venta: row.punto_venta?.trim() || null,
                    documento_numero: row.documento_numero?.trim() || null,
                    fecha_rendicion: row.fecha_rendicion ? new Date(row.fecha_rendicion).toISOString().split('T')[0] : null,
                    rendicion: row.rendicion?.trim() || null,
                    importe: row.importe || 0,
                    cancelado: row.cancelado || 0,
                    vencimiento: row.vencimiento ? new Date(row.vencimiento).toISOString().split('T')[0] : null
                };
            }).filter(r => r !== null);

            if (headersToInsert.length > 0) {
                const { error: insertError } = await supabase
                    .from('cuentas_corrientes')
                    .insert(headersToInsert);

                if (insertError) {
                    console.error(`‚ùå Error en lote ${i / BATCH_SIZE + 1}:`, insertError.message);
                    errors.push(`Lote ${i / BATCH_SIZE + 1}: ${insertError.message}`);
                } else {
                    successCount += headersToInsert.length;
                    console.log(`‚úÖ Lote ${i / BATCH_SIZE + 1}: ${headersToInsert.length} registros migrados`);
                }
            }

            skippedCount += (batch.length - headersToInsert.length);
        }

        console.log(`\n‚úÖ Headers migrados: ${successCount}`);
        console.log(`‚ö†Ô∏è  Headers omitidos: ${skippedCount}`);

        // PASO 4: Migrar detalles
        console.log('\nüìã PASO 4: Migrando detalle_cuentas_corrientes (items)...');

        const detallesQuery = `
            SELECT
                dcc.idtransaccion,
                dcc.Item as item,
                dcc.Concepto as concepto,
                dcc.Cantidad as cantidad,
                dcc.Importe as importe
            FROM detallecuentascorrientes dcc
            INNER JOIN cuentascorrientes cc ON dcc.idtransaccion = cc.IdTransaccion
            WHERE cc.socio < 10000
            ORDER BY dcc.idtransaccion, dcc.Item
        `;

        const detallesResult = await pool.request().query(detallesQuery);
        console.log(`üìñ Encontrados ${detallesResult.recordset.length} items en SQL Server`);

        // Obtener IDs de transacciones migradas exitosamente (con paginaci√≥n)
        let allTransacciones = [];
        let fromTrans = 0;
        const pageSizeTrans = 1000;

        while (true) {
            const { data: transaccionesMigradas, error: transError } = await supabase
                .from('cuentas_corrientes')
                .select('idtransaccion')
                .range(fromTrans, fromTrans + pageSizeTrans - 1);

            if (transError) {
                console.error('‚ùå Error obteniendo transacciones migradas:', transError);
                throw transError;
            }

            if (!transaccionesMigradas || transaccionesMigradas.length === 0) break;

            allTransacciones = allTransacciones.concat(transaccionesMigradas);

            if (transaccionesMigradas.length < pageSizeTrans) break;
            fromTrans += pageSizeTrans;
        }

        const transaccionesIds = new Set(allTransacciones.map(t => t.idtransaccion));
        console.log(`‚úÖ ${transaccionesIds.size} transacciones disponibles para detalles`);

        let detalleSuccessCount = 0;
        let detalleSkippedCount = 0;

        for (let i = 0; i < detallesResult.recordset.length; i += BATCH_SIZE) {
            const batch = detallesResult.recordset.slice(i, i + BATCH_SIZE);

            const detallesToInsert = batch.map(row => {
                // Validar que la transacci√≥n existe
                if (!transaccionesIds.has(row.idtransaccion)) {
                    errors.push(`Transacci√≥n ${row.idtransaccion} no existe para item ${row.item}`);
                    return null;
                }

                // Validar que el concepto existe
                const conceptoCodigo = row.concepto?.trim();
                if (!conceptosCodigos.has(conceptoCodigo)) {
                    errors.push(`Concepto '${conceptoCodigo}' no existe (transacci√≥n: ${row.idtransaccion})`);
                    return null;
                }

                return {
                    idtransaccion: row.idtransaccion,
                    item: row.item,
                    concepto: conceptoCodigo,
                    cantidad: row.cantidad || 1,
                    importe: row.importe || 0
                };
            }).filter(r => r !== null);

            if (detallesToInsert.length > 0) {
                const { error: insertError } = await supabase
                    .from('detalle_cuentas_corrientes')
                    .insert(detallesToInsert);

                if (insertError) {
                    console.error(`‚ùå Error en lote de detalles ${i / BATCH_SIZE + 1}:`, insertError.message);
                    errors.push(`Lote detalles ${i / BATCH_SIZE + 1}: ${insertError.message}`);
                } else {
                    detalleSuccessCount += detallesToInsert.length;
                    console.log(`‚úÖ Lote detalles ${i / BATCH_SIZE + 1}: ${detallesToInsert.length} items migrados`);
                }
            }

            detalleSkippedCount += (batch.length - detallesToInsert.length);
        }

        console.log(`\n‚úÖ Items migrados: ${detalleSuccessCount}`);
        console.log(`‚ö†Ô∏è  Items omitidos: ${detalleSkippedCount}`);

        // PASO 5: Resetear secuencia
        console.log('\nüìã PASO 5: Reseteando secuencia de idtransaccion...');

        const maxIdQuery = await supabase
            .from('cuentas_corrientes')
            .select('idtransaccion')
            .order('idtransaccion', { ascending: false })
            .limit(1);

        if (maxIdQuery.data && maxIdQuery.data.length > 0) {
            const maxId = maxIdQuery.data[0].idtransaccion;
            const { error: seqError } = await supabase.rpc('reset_sequence', {
                seq_name: 'cuentas_corrientes_idtransaccion_seq',
                next_val: maxId + 1
            });

            if (seqError) {
                console.log('‚ö†Ô∏è  No se pudo resetear la secuencia autom√°ticamente.');
                console.log(`   Ejecut√° manualmente: SELECT setval('cuentas_corrientes_idtransaccion_seq', ${maxId + 1}, false);`);
            } else {
                console.log(`‚úÖ Secuencia reseteada a ${maxId + 1}`);
            }
        }

        // PASO 6: Resumen y errores
        console.log('\n' + '='.repeat(60));
        console.log('üìä RESUMEN DE MIGRACI√ìN');
        console.log('='.repeat(60));
        console.log(`Headers migrados:    ${successCount}`);
        console.log(`Headers omitidos:    ${skippedCount}`);
        console.log(`Items migrados:      ${detalleSuccessCount}`);
        console.log(`Items omitidos:      ${detalleSkippedCount}`);
        console.log(`Errores encontrados: ${errors.length}`);

        if (errors.length > 0) {
            console.log('\n‚ö†Ô∏è  ERRORES DETALLADOS (primeros 20):');
            errors.slice(0, 20).forEach((err, idx) => {
                console.log(`   ${idx + 1}. ${err}`);
            });
            if (errors.length > 20) {
                console.log(`   ... y ${errors.length - 20} errores m√°s`);
            }
        }

        console.log('\n‚úÖ Migraci√≥n completada!');

        await pool.close();

    } catch (error) {
        console.error('\n‚ùå Error fatal en migraci√≥n:', error);
        throw error;
    }
}

// Ejecutar migraci√≥n
migrateCuentasCorrientes()
    .then(() => {
        console.log('\nüéâ Proceso finalizado exitosamente');
        process.exit(0);
    })
    .catch(error => {
        console.error('\nüí• Proceso finalizado con errores:', error);
        process.exit(1);
    });
